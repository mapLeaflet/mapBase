{"version":3,"sources":["BoundaryCanvas.js"],"names":["window","factory","exports","console","log","module","require","define","L","BoundaryCanvas","this","isRingBbox","ring","bbox","length","p","sumX","sumY","x","min","max","y","ExtendMethods","_toMercGeometry","b","isGeoJSON","c","r","mercComponent","mercRing","coords","res","Array","latLng","push","_map","project","_getOriginalMercBoundary","_mercBoundary","compomentBbox","Util","isArray","options","boundary","processGeoJSONObject","obj","type","geometries","forEach","geometry","features","concat","coordinates","bind","_mercBbox","Bounds","extend","_getClippedGeometry","geom","bounds","clippedComponent","clippedExternalRing","clippedHoleRing","iC","iR","clippedGeom","PolyUtil","clipPolygon","isOut","isIn","_getTileGeometry","z","skipIntersectionCheck","parentState","cacheID","zCoeff","Math","pow","cache","_boundaryCache","mercBoundary","ts","tileSize","tileBbox","Point","intersects","floor","_drawTileInternal","canvas","tilePoint","url","callback","zoom","_getZoomForUrl","state","tileX","tileY","ctx","getContext","imageObj","Image","setPattern","pattern","beginPath","moveTo","lineTo","clip","createPattern","rect","width","height","fillStyle","fill","crossOrigin","onload","complete","setTimeout","src","onAdd","map","TileLayer","Canvas","prototype","call","trackAttribution","on","_updateAttribution","onRemove","off","_attributionRemoved","attribution","getAttribution","attributionControl","removeAttribution","mapBounds","getBounds","mercBounds","getSouthWest","getNorthEast","version","includes","initialize","createTile","done","tile","document","createElement","getTileUrl","setOptions","async","_url","drawTile","adjustedTilePoint","_adjustTilePoint","tileDrawn","_getTileSize","style","boundaryCanvas","createFromLayer","layer","layerName","geoData"],"mappings":"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","file":"BoundaryCanvas.js","sourcesContent":["/**\n * Created by liaohui1080 on 2017/6/8.\n *\n * leaflet-boundary-canvas 插件\n * 使用了 canvas html5元素 ,所以不兼容 低版本的ie\n */\n\n\n(function (window, factory) {\n    if (typeof exports === 'object') {\n        console.log('CommonJS')\n        module.exports = factory(require('leaflet'));\n\n\n    } else if (typeof define === 'function') {\n        console.log('amd or cmd')\n\n        //amd调用这个\n        define(['leaflet'], factory);\n\n        //cmd 调用这个\n        define(function (require, exports, module) {\n\n            module.exports=factory(window.L)\n        });\n    } else {\n        console.log('原生');\n\n        window.BoundaryCanvas = factory(window.L)\n\n    }\n})(this, function (L) {\n\n    (function() {\n\n        'use strict';\n\n        var isRingBbox = function (ring, bbox) {\n            if (ring.length !== 4) {\n                return false;\n            }\n\n            var p, sumX = 0, sumY = 0;\n\n            for (p = 0; p < 4; p++) {\n                if ((ring[p].x !== bbox.min.x && ring[p].x !== bbox.max.x) ||\n                    (ring[p].y !== bbox.min.y && ring[p].y !== bbox.max.y)) {\n                    return false;\n                }\n\n                sumX += ring[p].x;\n                sumY += ring[p].y;\n\n                //bins[Number(ring[p].x === bbox.min.x) + 2 * Number(ring[p].y === bbox.min.y)] = 1;\n            }\n\n            //check that we have all 4 vertex of bbox in our geometry\n            return sumX === 2*(bbox.min.x + bbox.max.x) && sumY === 2*(bbox.min.y + bbox.max.y);\n        };\n\n        var ExtendMethods = {\n            _toMercGeometry: function(b, isGeoJSON) {\n                var res = [];\n                var c, r, p,\n                    mercComponent,\n                    mercRing,\n                    coords;\n\n                if (!isGeoJSON) {\n                    if (!(b[0] instanceof Array)) {\n                        b = [[b]];\n                    } else if (!(b[0][0] instanceof Array)) {\n                        b = [b];\n                    }\n                }\n\n                for (c = 0; c < b.length; c++) {\n                    mercComponent = [];\n                    for (r = 0; r < b[c].length; r++) {\n                        mercRing = [];\n                        for (p = 0; p < b[c][r].length; p++) {\n                            coords = isGeoJSON ? L.latLng(b[c][r][p][1], b[c][r][p][0]) : b[c][r][p];\n                            mercRing.push(this._map.project(coords, 0));\n                        }\n                        mercComponent.push(mercRing);\n                    }\n                    res.push(mercComponent);\n                }\n\n                return res;\n            },\n\n            //lazy calculation of layer's boundary in map's projection. Bounding box is also calculated\n            _getOriginalMercBoundary: function () {\n                if (this._mercBoundary) {\n                    return this._mercBoundary;\n                }\n\n                var compomentBbox, c;\n\n                if (L.Util.isArray(this.options.boundary)) { //Depricated: just array of coordinates\n                    this._mercBoundary = this._toMercGeometry(this.options.boundary);\n                } else { //GeoJSON\n                    this._mercBoundary = [];\n                    var processGeoJSONObject = function(obj) {\n                        if (obj.type === 'GeometryCollection') {\n                            obj.geometries.forEach(processGeoJSONObject);\n                        } else if (obj.type === 'Feature') {\n                            processGeoJSONObject(obj.geometry);\n                        } else if (obj.type === 'FeatureCollection') {\n                            obj.features.forEach(processGeoJSONObject);\n                        } else if (obj.type === 'Polygon') {\n                            this._mercBoundary = this._mercBoundary.concat(this._toMercGeometry([obj.coordinates], true));\n                        } else if (obj.type === 'MultiPolygon') {\n                            this._mercBoundary = this._mercBoundary.concat(this._toMercGeometry(obj.coordinates, true));\n                        }\n                    }.bind(this);\n                    processGeoJSONObject(this.options.boundary);\n                }\n\n                this._mercBbox = new L.Bounds();\n                for (c = 0; c < this._mercBoundary.length; c++) {\n                    compomentBbox = new L.Bounds(this._mercBoundary[c][0]);\n                    this._mercBbox.extend(compomentBbox.min);\n                    this._mercBbox.extend(compomentBbox.max);\n                }\n\n                return this._mercBoundary;\n            },\n\n            _getClippedGeometry: function(geom, bounds) {\n                var clippedGeom = [],\n                    clippedComponent,\n                    clippedExternalRing,\n                    clippedHoleRing,\n                    iC, iR;\n\n                for (iC = 0; iC < geom.length; iC++) {\n                    clippedComponent = [];\n                    clippedExternalRing = L.PolyUtil.clipPolygon(geom[iC][0], bounds);\n                    if (clippedExternalRing.length === 0) {\n                        continue;\n                    }\n\n                    clippedComponent.push(clippedExternalRing);\n\n                    for (iR = 1; iR < geom[iC].length; iR++) {\n                        clippedHoleRing = L.PolyUtil.clipPolygon(geom[iC][iR], bounds);\n                        if (clippedHoleRing.length > 0) {\n                            clippedComponent.push(clippedHoleRing);\n                        }\n                    }\n                    clippedGeom.push(clippedComponent);\n                }\n\n                if (clippedGeom.length === 0) { //we are outside of all multipolygon components\n                    return {isOut: true};\n                }\n\n                for (iC = 0; iC < clippedGeom.length; iC++) {\n                    if (isRingBbox(clippedGeom[iC][0], bounds)) {\n                        //inside exterior rings and no holes\n                        if (clippedGeom[iC].length === 1) {\n                            return {isIn: true};\n                        }\n                    } else { //intersects exterior ring\n                        return {geometry: clippedGeom};\n                    }\n\n                    for (iR = 1; iR < clippedGeom[iC].length; iR++) {\n                        //inside exterior ring, but have intersection with a hole\n                        if (!isRingBbox(clippedGeom[iC][iR], bounds)) {\n                            return {geometry: clippedGeom};\n                        }\n                    }\n                }\n\n                //we are inside all holes in geometry\n                return {isOut: true};\n            },\n\n            // Calculates intersection of original boundary geometry and tile boundary.\n            // Uses quadtree as cache to speed-up intersection.\n            // Return\n            //   {isOut: true} if no intersection,\n            //   {isIn: true} if tile is fully inside layer's boundary\n            //   {geometry: <LatLng[][][]>} otherwise\n            _getTileGeometry: function (x, y, z, skipIntersectionCheck) {\n                if ( !this.options.boundary) {\n                    return {isIn: true};\n                }\n\n                var cacheID = x + \":\" + y + \":\" + z,\n                    zCoeff = Math.pow(2, z),\n                    parentState,\n                    cache = this._boundaryCache;\n\n                if (cache[cacheID]) {\n                    return cache[cacheID];\n                }\n\n                var mercBoundary = this._getOriginalMercBoundary(),\n                    ts = this.options.tileSize,\n                    tileBbox = new L.Bounds(new L.Point(x * ts / zCoeff, y * ts / zCoeff), new L.Point((x + 1) * ts / zCoeff, (y + 1) * ts / zCoeff));\n\n                //fast check intersection\n                if (!skipIntersectionCheck && !tileBbox.intersects(this._mercBbox)) {\n                    return {isOut: true};\n                }\n\n                if (z === 0) {\n                    cache[cacheID] = {geometry: mercBoundary};\n                    return cache[cacheID];\n                }\n\n                parentState = this._getTileGeometry(Math.floor(x / 2), Math.floor(y / 2), z - 1, true);\n\n                if (parentState.isOut || parentState.isIn) {\n                    return parentState;\n                }\n\n                cache[cacheID] = this._getClippedGeometry(parentState.geometry, tileBbox);\n                return cache[cacheID];\n            },\n\n            _drawTileInternal: function (canvas, tilePoint, url, callback) {\n                var zoom = this._getZoomForUrl(),\n                    state = this._getTileGeometry(tilePoint.x, tilePoint.y, zoom);\n\n                if (state.isOut) {\n                    callback();\n                    return;\n                }\n\n                var ts = this.options.tileSize,\n                    tileX = ts * tilePoint.x,\n                    tileY = ts * tilePoint.y,\n                    zCoeff = Math.pow(2, zoom),\n                    ctx = canvas.getContext('2d'),\n                    imageObj = new Image(),\n                    _this = this;\n\n                var setPattern = function () {\n                    var c, r, p,\n                        pattern,\n                        geom;\n\n                    if (!state.isIn) {\n                        geom = state.geometry;\n                        ctx.beginPath();\n\n                        for (c = 0; c < geom.length; c++) {\n                            for (r = 0; r < geom[c].length; r++) {\n                                if (geom[c][r].length === 0) {\n                                    continue;\n                                }\n\n                                ctx.moveTo(geom[c][r][0].x * zCoeff - tileX, geom[c][r][0].y * zCoeff - tileY);\n                                for (p = 1; p < geom[c][r].length; p++) {\n                                    ctx.lineTo(geom[c][r][p].x * zCoeff - tileX, geom[c][r][p].y * zCoeff - tileY);\n                                }\n                            }\n                        }\n                        ctx.clip();\n                    }\n\n                    pattern = ctx.createPattern(imageObj, \"repeat\");\n                    ctx.beginPath();\n                    ctx.rect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = pattern;\n                    ctx.fill();\n                    callback();\n                };\n\n                if (this.options.crossOrigin) {\n                    imageObj.crossOrigin = '';\n                }\n\n                imageObj.onload = function () {\n                    //TODO: implement correct image loading cancelation\n                    canvas.complete = true; //HACK: emulate HTMLImageElement property to make happy L.TileLayer\n                    setTimeout(setPattern, 0); //IE9 bug - black tiles appear randomly if call setPattern() without timeout\n                }\n\n                imageObj.src = url;\n            },\n\n            onAdd: function(map) {\n                (L.TileLayer.Canvas || L.TileLayer).prototype.onAdd.call(this, map);\n\n                if (this.options.trackAttribution) {\n                    map.on('moveend', this._updateAttribution, this);\n                    this._updateAttribution();\n                }\n            },\n\n            onRemove: function(map) {\n                (L.TileLayer.Canvas || L.TileLayer).prototype.onRemove.call(this, map);\n\n                if (this.options.trackAttribution) {\n                    map.off('moveend', this._updateAttribution, this);\n                    if (!this._attributionRemoved) {\n                        var attribution = L.TileLayer.BoundaryCanvas.prototype.getAttribution.call(this);\n                        map.attributionControl.removeAttribution(attribution);\n                    }\n                }\n            },\n\n            _updateAttribution: function() {\n                var geom = this._getOriginalMercBoundary(),\n                    mapBounds = this._map.getBounds(),\n                    mercBounds = L.bounds(this._map.project(mapBounds.getSouthWest(), 0), this._map.project(mapBounds.getNorthEast(), 0)),\n                    state = this._getClippedGeometry(geom, mercBounds);\n\n                if (this._attributionRemoved !== !!state.isOut) {\n                    var attribution = L.TileLayer.BoundaryCanvas.prototype.getAttribution.call(this);\n                    this._map.attributionControl[state.isOut ? 'removeAttribution' : 'addAttribution'](attribution);\n                    this._attributionRemoved = !!state.isOut;\n                }\n            }\n        };\n\n        if (L.version >= '0.8') {\n            L.TileLayer.BoundaryCanvas = L.TileLayer.extend({\n                options: {\n                    // all rings of boundary should be without self-intersections or intersections with other rings\n                    // zero-winding fill algorithm is used in canvas, so holes should have opposite direction to exterior ring\n                    // boundary can be\n                    // LatLng[] - simple polygon\n                    // LatLng[][] - polygon with holes\n                    // LatLng[][][] - multipolygon\n                    boundary: null\n                },\n                includes: ExtendMethods,\n                initialize: function(url, options) {\n                    L.TileLayer.prototype.initialize.call(this, url, options);\n                    this._boundaryCache = {}; //cache index \"x:y:z\"\n                    this._mercBoundary = null;\n                    this._mercBbox = null;\n\n                    if (this.options.trackAttribution) {\n                        this._attributionRemoved = true;\n                        this.getAttribution = null;\n                    }\n                },\n                createTile: function(coords, done){\n                    var tile = document.createElement('canvas'),\n                        url = this.getTileUrl(coords);\n                    tile.width = tile.height = this.options.tileSize;\n                    this._drawTileInternal(tile, coords, url, L.bind(done, null, null, tile));\n\n                    return tile;\n                }\n            })\n        } else {\n            L.TileLayer.BoundaryCanvas = L.TileLayer.Canvas.extend({\n                options: {\n                    // all rings of boundary should be without self-intersections or intersections with other rings\n                    // zero-winding fill algorithm is used in canvas, so holes should have opposite direction to exterior ring\n                    // boundary can be\n                    // LatLng[] - simple polygon\n                    // LatLng[][] - polygon with holes\n                    // LatLng[][][] - multipolygon\n                    boundary: null\n                },\n                includes: ExtendMethods,\n                initialize: function (url, options) {\n                    L.Util.setOptions(this, options);\n                    L.Util.setOptions(this, {async: true}); //image loading is always async\n                    this._url = url;\n                    this._boundaryCache = {}; //cache index \"x:y:z\"\n                    this._mercBoundary = null;\n                    this._mercBbox = null;\n\n                    if (this.options.trackAttribution) {\n                        this._attributionRemoved = true;\n                        this.getAttribution = null;\n                    }\n                },\n\n                drawTile: function(canvas, tilePoint) {\n                    var adjustedTilePoint = L.extend({}, tilePoint),\n                        url;\n\n                    this._adjustTilePoint(adjustedTilePoint);\n                    url = this.getTileUrl(adjustedTilePoint);\n                    this._drawTileInternal(canvas, tilePoint, url, L.bind(this.tileDrawn, this, canvas));\n\n                    //Leaflet v0.7.x bugfix (L.Tile.Canvas doesn't support maxNativeZoom option)\n                    if (this._getTileSize() !== this.options.tileSize) {\n                        canvas.style.width = canvas.style.height = this._getTileSize() + 'px';\n                    }\n                }\n            });\n        }\n\n        L.TileLayer.boundaryCanvas = function (url, options) {\n            return new L.TileLayer.BoundaryCanvas(url, options);\n        };\n\n        L.TileLayer.BoundaryCanvas.createFromLayer = function (layer, options) {\n            return new L.TileLayer.BoundaryCanvas(layer._url, L.extend({}, layer.options, options));\n        };\n\n    })();\n\n\n\n\n    //geo边界,用来圈出当前加载geo区域的地图\n    //layerName 地图源名字\n    //geoData geo区域数据\n\n    var BoundaryCanvas = function (layerName, geoData) {\n        return L.TileLayer.BoundaryCanvas.createFromLayer(\n            layerName,\n            {boundary: geoData, trackAttribution: true}\n        )\n    };\n\n\n    return BoundaryCanvas\n\n\n\n});\n"]}